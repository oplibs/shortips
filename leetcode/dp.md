# dp #

最后再谈谈「无后效性」
「无后效性」是我多次提到的一个「动态规划」中非常重要的概念，在我看来，理解这个概念无比重要。很遗憾，《算法导论》上没有讲到「无后效性」。我找了一本在「豆瓣」目前豆瓣上评分为 9.2 的书 《算法竞赛进阶指南》，这本书和《算法导论》《算法 4》和 liuyubobobo 老师的算法课程一样，在我学习算法与数据结构的道路上，都发挥了巨大的作用。

李煜东著《算法竞赛进阶指南》，摘录如下：：

为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。

我的解释：

「有向无环图」「拓扑序」表示了每一个子问题只求解一次，以后求解问题的过程不会修改以前求解的子问题的结果；
换句话说：如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫「有后效性」，我们在当前这个问题第 1 次拆分的子问题就是「有后效性」的（大家可以再翻到上面再看看）；
解决「有后效性」的办法是固定住需要分类讨论的地方，记录下更多的结果。在代码层面上表现为：
状态数组增加维度，例如：「力扣」的股票系列问题；
把状态定义得更细致、准确，例如：前天推送的第 124 题：状态定义只解决路径来自左右子树的其中一个子树。

链接：https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/

=======================================================================================================================================
## 回文-Edit Distance ##

S是字符串
P[i, j] :表示[i,j]之间的子字符串是否回文：

P[i, j]
* = P[i+1, j-1] if S[i]==S[j]
* = false if S[i]!=S[j]

参考:([#q5](#q5))
* [关于回文串的状态转换矩阵以及矩阵的遍历填值逻辑] ([#q5](#q5)), 遍历顺序是初始字符串长度
* 回文的转换矩阵可能是自己和自己比，因此虽然是矩阵，其实只有三角形有意义。 ([#q5](#q5))
* 删除相关的editdistance状态方程 ([#q583](#q583))


([#q131](#q131)) ([#q132](#q132))
131 [*] 分割回文串: 回溯的写法, dp用来加速回文的判断过程。递归的写法。
132 [*] 分割回文串 II :递推法对应的状态方程，用回溯来判断最终结果。新的状态公式
* [X] 最长公共子串的状态方程 (q1143)
'''
https://leetcode.cn/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/
'''

=======================================================================================================================================
## 有效的排列组合 ##
([#q22](#q22))
括号的排列组合：
"("+a+")"+b : a,b均为合法的组合， a+b的有效括号数是n-1
利用dp模拟括号归纳法，达成回溯的作用。关键在于思路。
* ############################## 如此设计的原因起源于是括号必然是成对出现的。
类似的题目还有 ([#q95](#q95))([#q96](#q96))

([#q32](#q32))
最长有效括号子串
dp[i]
* = 0                         if S[i]=='('
* = dp[i-2]+2                 if S[i]==')' and S[i-1]=='('
* = dp[i-1]+dp[i-dp[i-1]-2]+2 if S[i]==')' and S[i-1]=='(' and S[i-dp[i-1]-1]=='('

([#q241](#q241))
为运算表达式设计优先级

([#q276](#q276))
栅栏涂色：方程的思路

=======================================================================================================================================
## 数组相关 ##
#############子序列型问题：
([#q97](#q97))
交错的字符串
dp[i] [j]:代表子字符串s1[i], s2[j]是否能够正好组成s3[0, i+j]这个字符串。
dp[i] [j]=
# =( dp[i-1] [j] and s3[i+j-1]==s1[i-1] ) or ( dp[i] [j-1] and s3[i+j-1]==s2[j-1] )

([#q115](#q115))
翻译题意
读懂题目后，用自己的话“翻译”一下题目，有时候会更容易有思路。
题目：求 s 的子序列中 t 出现的个数，blabla...
翻译：在 s 串身上 “挑选” 字符，去匹配 t 串的字符，求挑选的方式数

递归思路
抓住 “选”，s 要照着 t 来挑选，逐字符考察选或不选，分别来到什么状态？

举例，s 为babgbag，t 为bag，末尾字符相同，于是 s 有两种选择：
* 用s[s.length-1]去匹配掉t[t.length-1]，问题规模缩小：继续考察babgba和ba
* 不这么做，但t[t.length-1]仍需被匹配，于是在babgba中继续挑，考察babgba和bag

是否用它去匹配，是两种不同的挑选方式，各自做下去所产生的方式数，相加，是大问题的解。

现在我们拆解出规模小一点的子问题。完善一下，定义出递归函数：

返回：从开头到s[i]的子串中，出现『从开头到t[j]的子串』的次数。
即，从 前者 选字符，去匹配 后者，的方案数。

看了s[i]==t[j]的情况，那s[i]!=t[j]的情况呢？s[i]不匹配t[j]，唯有拿s[i]之前的子串去匹配

现在两种情况下的递归公式都好写了。递归树底部的 base case 呢？

随着递归压栈，子问题规模（子串长度）在变小：

小到 t 变成空串，此时 s 为了匹配它，方式只有1种：什么字符也不用挑（或 s 也是空串，什么都不做就匹配了，方式数也是1）
小到 s 变成空串，但 t 不是，s 怎么也匹配不了 t，方式数为 0
递归函数的参数可以传子串或索引，但用索引描述子问题，不用每次都切割字符串，也更容易迁移到 dp 解法。

dp[i] [j]
* = dp[i-1] [j]+ dp[i-1] [j-1]      if S[i]==T[j]
* = dp[i-1] [j]                     if S[i]!=T[j]
这里需要重点考虑t是必须要被匹配的的。

链接：https://leetcode.cn/problems/distinct-subsequences/solution/shou-hua-tu-jie-xiang-jie-liang-chong-ji-4r2y/

([#q152](#q152))
乘积最大的子数组，因为是乘积，因此有一个转化的过程，所以状态要设计成最大和最小：
Fmax[i]=max(nums[i], Fmax[i-1]*nums[i], Fmin[i-1]*nums[i]);
Fmin[i]=min(nums[i], Fmin[i-1]*nums[i], Fmax[i-1]*nums[i]);

([#q300](#q300))
最长递增子序列

([#q487](#q487))
最大连续1的个数 II 状态转换的考虑，相对比较简单


=======================================================================================================================================
## 股票类的思路 - 打劫思路类似
([#q121](#q121)) ([#q122](#q122)) ([#q123](#q123)) ([#q188](#q188)) ([#q309](#q309)) ([#q714](#q714))
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/
股票类的状态方程
121: easy
122: easy
123 188 309 714 的转换方程指的仔细看看

打家劫舍题目
([#q198](#q198))([#q213](#q213)) ([#q337](#q337))






=======================================================================================================================================
## 背包问题
256 粉刷房子
265 粉刷房子 II
294 翻转游戏 II

=======================================================================================================================================

## 数字n相关的归纳法+数字相关 ##
([#q264](#q264)) ([#q279](#q279)) ([#q313](#q313))
这类多指针的算法可以简化各种简化基数排序的工作:
264 [*] 丑数 II ************* 考虑如何用堆，如何比较巧妙的用组合方法，三指针真赞。
279 完全平方数
313 [*] 超级丑数 ************* 考虑如何用堆，如何比较巧妙的用组合方法
343 [*] 整数拆分



=======================================================================================================================================
## 正则类问题
([#q10](#q10))([#q44](#q44))

=======================================================================================================================================
## 比较简单的题目
53 [-] 最大子数组和
62 [-] 不同路径
63 [-] 不同路径 II
64 [-] 最小路径和
91 [-] 解码方法


















=======================================================================================================================================
([#486](#486)) 预测赢家：递归的方法可以设计，看看这个时候dp的转换方程。
([#494](#494))优化思路的转换

#### 状态方程 ####
状态方程：
#### 归纳法 - 类似于递归（分治）类问题的思路 ####
91 [X] ====比较好写
96 [X] ====不同二叉树的数量，排列组合与dp的深度结合
([#q279](#q279))
279 [ ] 不是很容易想到，写法注意牵涉到浮点数精度的各种边界条件考虑。
120 [X] 归纳法，三角形的写法。
([#q204](#q204))
([#q254](#q254)) [X] easy 计数质数 计数最好都考虑一下归纳或者dp
#### 与贪心的结合 ####
45 [X] 其实并不是标准的dp，需要明白建模的重要性。
55 [X] 边界条件注意一下


97 [X] 写一下转换方程
1027 最长等差数列

待进一步学习：
q85 q87



TODO:
2022.09.03
q85 q87
([#q174](#q174)) ([#q233](#q233))
q329
q486
