# Contents

## question list ##

== questions ==
-: 暂时忽略
X: 偏基本功，注意边界条件和基本写法，适合快速复习
#: 偏基本功，可以从多种解法的角度来写。
*: coding熟悉，需要完整的写一遍
+: 重点复习，包括思路的考量

R: 抽时间细看
#: 利用leisuretime写一下
o: others

===med===
### 1-100 ###
1 [-] two sum: easy
2 [-] 两数相加: easy
# q3
3 [X-#] 无重复字符的最长子串: DP的转换方程
4 [*] 寻找两个正序数组的中位数
# q5
5 [X] 长回文子串:回文相关 方法一好些，dp解法需要写一下。
6 [X] Z字形变换: Done用公式
7 [X] 整数反转,负数和corner case.
8 [ ]  字符串转换整数 (atoi)
9 [X]  数字回文，数字不用字符串stack的做法是构造这个数字。
10 [ ]  ==========================有空再看
11 [X] 最多水的容器: ------------------贪心的分析方法，枚举后优化递进的方法。
12 [X] 数转罗马数字: ------------------区间的玩法。
13 [X] 数转罗马数字: ------------------区间的玩法。
14 [X] 最长公共前缀，可以简单看一下题解的说明
15 [*] 三数之和 : 16 18
16 [*] 接近的三数之和
17 [X] 电话号码的字母组合
18 [*] 四数之和
19 [X] 除链表的倒数第 N 个结点:
20 [*] 有效的括号.
21 [X] 合并两个有序链表
22 [*] 括号生成 dp
23 [ ] 合并K个升序链表
# q递归链表
24 [+] 两两交换链表中的节点 递归的设计方法:交换链表中的节点
25 [+] K 个一组翻转链表: 递归的设计方法：交换链表中的节点
# q26
26 [X] 基本功：删除有序数组中的重复项
27 [X] 基本功：同27
28 [ ] 实现 strStr()
29 [-] 两数相除: 有空就看看吧，定义比较麻烦
# q30
30 [#] 串联所有单词的子串：tips值得看一下滑动窗口的不同尺度（字符，单词），降低复杂度
31 [+] 最长有效括号，状态：+++++++++++++++++++++了解一下遍历顺序
32 [ ] 下一个排列 =================没看懂
# q33
33 [X] 搜索旋转排序数组:下一个排列 --------快速看看边界条件
# q34
34 [+] 有重复元素排序数组中查找元素的第一个和最后一个位置
# q35
35 [ ] 查找可能不存在的有序数组，最关键的是一点是要记录当前挪动到mid指针的状态，并记录记录记录。
# q36
36 [X] ------------有效的数独，参考一下map的设计方法。
37 [ ] 解数独
38 [X] 外观数列-----最后一哆嗦
39 [X] 组合总和 -----参考一下分析方法而已
40 [X] 组合总和 II
41 [+] 缺失的第一个证书，可以看看分析，主要是终止条件。
42 [R] 接雨水
43 [X] 字符串相乘
44 [R] 通配符匹配
45 [X] [*] 跳跃游戏 II ----------------主要能达成最远和最大步数的差异，用来设置两个终止条件，还是要优化自己的思路。学习一下倒追算法 ([#55](#55))
46 [X] 排列 和组合的差异就是在于按照顺序遍历的时候，组合是按照选和不选做两种遍历，排列是每次选走随机一个，然后做组合。
47 [X] 排列 II
48 转图像
49 [X] 母异位词分组，就是看看如何编码。
50 w(x, n)
# q53
53 [X] 最大子数组和
54 [#] 螺旋矩阵
# q55
55 [*] 跳跃游戏: 最大到达点和步数要分别维护`
56 [ ] [*] 值得参考的写法： 先增加，根据iterate到的item去修改上一个，比在iterate的时候动态触发新增item更强一些.
57 [*] 插入区间
58 [X] 最后一个单词的长度
59 [X] 螺旋矩阵 II
60 [#] 排序序列-字典序
61 [X] 翻转链表: ---------------利用快慢指针的时候，快速指针寻尾的时候终止条件是fast->next != nullptr
62 [X] easy - 不同路径
63 [X] 不同路径 II
64 [X] easy - 最小路径和
65 [ ] 有效数字
66 [X] 加一：easy
67 [X] 二进制求和：easy - reverse这个helper
68 [ ] Text justification
69 [ ] X的平方根
70 [X] 爬楼梯
71 [ ] 简化路径
72 [+] 编辑距离
73 [X] 矩阵置零
# q74
74 [R] 检索二维矩阵
75 [ ] 颜色分类
76 [ ] 最小覆盖子串
77 [*] 组合：看一下注释
78 [*] 子集：看一下和77的差异
79 [R] 单词搜索dfs 写法
# q80
80 [*] 删除有序数组中的重复项 II ([#q26](#q26)) https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/
2其实就是窗口长度的意思
def removeDuplicates(self, nums: List[int]) -> int:
    cur = 2
    for end in range(2, len(nums)):
        if nums[end] != nums[cur - 2]:
            nums[cur] = nums[end]
            curj += 1  //更新到下一个待更新的节点，所以才会支持上面两行中!=j-2其实就是窗口长度的意思，每次都更新到待更新地点，然后和窗口前的比较即可。
    return cur
81 [*] 搜索旋转排序数组 II 边界条件存在各种相等的情况，这个时候指针按照1个挪动
# q82
82 [ ] 删除排序链表中的重复元素 II
# q83
83 [X] 删除排序链表中的重复元素
84 [ ] 柱状图中的最大举行
85 [ ] 最大举行
86 [X] 分隔链表
87 [ ] 扰乱字符串
88 [X] 合并两个有序数组
89 [ ] 格雷编码
90 [ ] 子集 II
91 [ ] 解码方法
92 [ ] 反转链表 II
93 [ ] 复原 IP 地址
94 [X] 二叉树中序遍历
95 [X] 不同的二叉搜索树 II =========================树的递归回溯的写法，可以当成参考模板进行复习。
96 [X] 不同的二叉搜索树
97 [*] 交错字符串
98 [*] 验证二叉搜索树 long long lastval = LONG_MIN;
99 [X] 恢复二叉搜索树
100 [X] 相同的树

93 [X] 验证二叉搜索树 ======================搜索树的中递归
94 [X] ============================== isBSTTree 容易写错, bst必然和遍历相关，所以状态比较可以从这个角度来说。
95 [X] 恢复二叉搜索树============================== 有两个元素错位了，写出来了，但是边界条件较为注意，一个是要注意遍历树是递归的，需要有个保险的方式终止循环。还有一个cornercase是最小值的问题（INT_MIN），注意画图确保前一个和后一个。另外就是手动画一下放错的两个元素相邻与不相邻的情况。

#### 101-200 ####
101 [X] 对称二叉树：快速复习一下写法，用递归的组合想问题
102 [X] 二叉树层序遍历：可以熟悉一下写法而已
103 [X] 二叉树的锯齿形层序遍历：基本同上
104 [X] 二叉树的最大深度
105 [ ] 从前序与中序遍历序列构造二叉树
106 [ ] 从中序与后序遍历序列构造二叉树
107 [X] 二叉树的层序遍历 II trickone
108 [X] 将有序数组转换为二叉搜索树
109 [ ] 有序链表转换二叉搜索树
110 [ ] 平衡二叉树
111 [ ] 二叉树最小深度
112 [X] 路径总和 easy
113 [X] 路径总和 II easy
114
# q115
115 [*] 不同的子序列 dp
116 [X] 填充每个节点的下一个右侧节点指针 easy
117 [X] 填充每个节点的下一个右侧节点指针II easy 不用队列更快，所以实现中时间还是管用的
118 [X] 杨辉三角 easy
119 [X] 杨辉三角II easy
120 [X] 三角形最小路径和 ===========triangle 最小路径（注意写法）
121 [X] 买卖股票的最佳时机 写的小心些。
122 [X] 买卖股票的最佳时机II dp
123 [X] 买卖股票的最佳时机III dp
124 [*] 二叉树中的最大路径和=========细心的看一下
125 [X] 验证回文串 =====考虑two pointer，还有更麻烦一些的字符串复制缩减的逻辑
# q126
126 [*] 单词接龙 II 图更好
127 [*] 单词接龙
128 [X] 最长连续序列 easy
129 [-] easy 求根节点到叶节点数字之和
130 [*] 被围绕的区域 ===dfs+bfs的标准写法
131 [*] 分割回文串
132 [ ] 分割回文串 II
133 [X] 克隆图: 练习一下遍历
134
135 [*] 分发糖果 *****************可以类比成双边限制条件下的策略。
136 [-] easy 出现一次的数字不会抑或
137
138
139 [ ] dp 写一下
142
143 [ ] 熟悉一下写法吧
146 [ ] 好好学习一下
147:148 : ******************************** 链表排序大成 *********快慢指针、merge链表、分治***链表处理头节点可以用个dummyHeader临时处理一下。****** 需要好好想一下downTOTop的设计流程
150 [X] easy
# q151
151 [*] 反转字符串中的单词 *************官方写法写的很干净
'''
while left <= right:
    if s[left] != ' ':
        output.append(s[left])
    elif output[-1] != ' ':
        output.append(s[left])
    left += 1
'''
152 [ ] dp, *******************注意状态转换别漏了
153 [ ] ] : 二分查找，注意边界条件
155 [ ] 设计设计设计设计
156 [-] 放弃
159 [*] twopointer，hashmap存位置,注意滑动窗口的模板。
160 [X] 相交链表： 看一下实现
161 [X] ] : 踏实的实现，cpp利用递归实现参数交换复制（switch）
162 [-] 这个条件很tricky nums[-1] = nums[n] = -∞
165 [ ] cpp的2 pointers实现split扫描
166
167 [-] EASY
171 [-] Excel 表列序号
172 [ ] ======== 定义sort函数:
173 [ ] 叉搜索树迭代器
174 [ ] 地下城游戏
175 [-] sql
176 [-] sql
177 [-] sql
178 [-] sql
179 [ ] 大数:******熟悉一下如何定义sort函数*******
180 [-] sql
187 [L] easy dna, 直接写
187 [ ] 买卖股票的最佳时机 IV
189 [X] ========= 数组挪动和反转的trick
190 [-] easy
192 [-] sql 统计词频
193 [-] bash 有效电话号码
194 [-] bash 转置文件
195 [-] bash 第十行
196 [-] sql 删除重复的电子邮箱
197 [-] sql 上升的温度
198 [ ] easy dp
199 [-] easy
200 [ ] 岛屿数量

==== 2?? ====
201 [#] 数字范围按位与 整理公共前缀的方法不错。
202 [-] easy 快乐数
203 [X] easy 移除链表元素
# q204
204 [X] easy 计数质数 计数最好都考虑一下归纳或者dp
205 [X] easy 双向 同构字符串
206 [X] 翻转链表=========递归的思路
207 [X] 课程表 好好写一下topsort
209 [X] ***注意终止条件。
213 [X] 打家劫舍 II ====easy
215 [*] 数组中的第K个最大元素
217 [-] 重复元素
229 [X] 多数元素 II ******注意边界条件
230 [X] 二叉搜索树中第K小的元素******注意递归如何有效终止。
231 [-] 2的n次幂
236 [*] 二叉树的最近公共祖先  ******** 看看递归的思路
237 [-] 删除链表中的节点
238 [ ] 单回忆一下
239 [ ] 滑动窗口最大值：
’‘’
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if(k==1){
            return nums;
        }
        vector<int> results(nums.size()-k+1);
        //queue存的可是位置
        deque<int> maxqueue;
        //1. 先初始化，少放一个，这样在正式循环中可以补充数字。[0,k-1)
        for(int i=0; i < k-1; i++){
            while(maxqueue.size()>0 && nums[maxqueue.back()]<nums[i]){
                maxqueue.pop_back();
            }
            maxqueue.push_back(i);
            //printf("pos size top: %d %d %d %d\n", i, maxqueue.size(), maxqueue.front(),nums[maxqueue.front()]);
        }
        //2. 正式循环中可以补充数字.
        //   字符串循环区间是：[k-1, n)
        //   写入位置是(i-k+1,可以从初始点推导出来)
        for(int i=k-1; i < nums.size(); i++){
            while (maxqueue.size()>0 && nums[i]>nums[maxqueue.back()]){
                maxqueue.pop_back();
            }
            maxqueue.push_back(i);
            //printf("pos size top: %d %d %d %d\n", i, maxqueue.size(), maxqueue.front(),nums[maxqueue.front()]);
            while(maxqueue.front()<=(i-k)){
                maxqueue.pop_front();
            }
            //printf("set: %d %d %d\n", i-k, maxqueue.front(),nums[maxqueue.front()]);
            results[i-k+1]=nums[maxqueue.front()];
        }

        return results;
    }
};
‘’‘
240 [X] 二维有序矩阵的查找…………
241 [*] 为运算表达式设计优先级…………
242 [-] 有效的字母异位词： *********** hash与sort可以有效结合
243 [X] 最短单词距离，一遍扫描
246 [X] 中心对称数： size_t 不是适合做双指针比较，因为非负的原因
247 [X] 中心对称数 II：容易一些。
# q254
254 [*] 因子的组合
263 [-] 丑数 <=非丑数
266 [-] 回文排列
# q279
279 [X] dp, *******************注意状态转换别漏了
298 [X] ======注意cache
299 [X] ======简单记忆一下

==== 3?? ====
365 [X] ************* 再仔细理解一下搜索 *********************
394 [X] =================进出栈的算法流程再熟悉一下。
395 [*] 至少有 K 个重复字符的最长子串:=================dfs+分治（其实也是递归）

==== 4?? ====
495 [X] easy
498 [X] 对角线遍历还好

=== 50? ===
500 [X] easy
501 [ ] binary search tree中序遍历其实就是从小到大排序遍历
502 [ ]  ????
503 [X] 用stack构建一个< >排序的方法......
# q583
[X] EditDistance DP

== TODO ==
=== cpp ===
#### tips ####
* size_t 不是适合做双指针比较，因为非负的原因
* [ ] 字符串排序 sort(t.begin(),t.end());

* union find
* bfs
* dfs
* 单调栈 496
* [X] sort

* math
'''
#include <algorithm>
std::max
'''
==== cpp ====
* [X] 如何定制sort函数 sort(vector<?>.begin, vector<?>.end);

## 算法复习要点 ##

### 基本功 ###
字符串和数组相同元素处理: ([#q151](#q151))

排列组合
question list:
https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {
    continue;
}
vis[i] : 组合的排序中表示某个数字已经用过了，需要加上visit标记
(i > 0 && nums[i] == nums[i - 1] && !vis[i - 1]):防止候选集合中有重复元素的情况（目前指的是排序后的）

if (vis[i] || (i > 0 && nums[i] == nums[i - 1]
    && !vis[i - 1])) continue;

链接：https://leetcode.cn/problems/permutations-ii/solution/quan-pai-lie-ii-by-leetcode-solution/
/* vis[i]：当前数字是否出现过
 * 如果当前数字与前一个数字相同（nums[i] == nums[i - 1]），
 * 并且前一个数字还没有出现的话（vis[i - 1] == false），
 * 那么就不能选择当前数字（continue），
 * 如果前面的数字已经出现过（vis[i] == true），则可以
 * 选择当前数字
 */
### 递归 ###
([#q递归链表](#q递归链表))

### binary search ###
* [X] 旋转后的检索方法。([#q33](#q33))
* [X] 如何在查找元素中有重复的场景下进行O(logN)类型的检索\如何处理等于条件下上下边界的调整方法，分成两段检索。([#q34](#q34)).
* [ ] 查找可能不存在元素的定位要注意。([#q35](#q35)).
* [ ] 二维快速检索复习一下边界条件 74 ([#74](#74))

#### 数组 ####

2数之和
3数之和
4数之和

#### 排序+双指针+滑动窗口 ####
([#q30](#q30))
#### 数组中重复
数组用buffer+双指针的位置迭代解决
([#q26](#q26)) ([#q80](#q80)) ([#q3](#q3))
#### 链表中重复
链表的搬家方式是改指针的链接方式，所以更麻烦一些
([#q82](#q82)) ([#q83](#q83))

#### 链表 ####
* 快慢指针
* 两个链表来回指向判断交叉
* 新建一个的dummy的头

### dp ###
#### 数字n相关的归纳法 ####

#### 回文相关 ####
* [关于回文串的状态转换矩阵以及矩阵的遍历填值逻辑] ([#q5](#q5)), 回文的转换矩阵可能是自己和自己比，因此虽然是矩阵，其实只有三角形有问题。 ([#q5](#q5))
#### edit distance相关 ####
删除相关的editdistance状态方程 ([#q583](#q583))
#### 子序列相关 ####
([#q53](#q53))
状态方程：([#q115](#q115))
#### 归纳法 ####
22. [X] ====利用dp模拟括号归纳法，达成回溯的作用。关键在于思路。
96. [X] ====不同二叉树的数量，排列组合与dp的深度结合
62. [-] easy
63. [-] easy
64. [-] easy
([#q279](#q279))
279. [ ] 不是很容易想到，写法注意牵涉到浮点数精度的各种边界条件考虑。
120. [X] 归纳法，三角形的写法。
([#q204](#q204))
([#q254](#q254)) [X] easy 计数质数 计数最好都考虑一下归纳或者dp
#### 与贪心的结合 ####
45. [X] 其实并不是标准的dp，需要明白建模的重要性。
55. [X] 边界条件注意一下


53. [ ] :
97. [X] 写一下转换方程
1027. 最长等差数列

### dfs bfs topsort union find ###

#### dfs ####
写法练习
79 基础练习
200 快速复习一下边界条件

#### bfs ####

#### topsort ####

#### union find ####


跟进
215
