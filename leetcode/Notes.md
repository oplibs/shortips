# Contents

- [include <algorithm>](#include <algorithm>)

== list ==

* 5 - all kinds of corner cases: string start and end, better unify loop policy.
* 64 - Dynamic Programming

== question ==

=== 快速复习 ===
==== 1-50 ====
2. [X] 写法和边界条件
3 写法和边界条件


=== binary search ===
74 快速复习一下边界条件

=== dp ===
==== 回文相关 ====
* 回文的转换矩阵可能是自己和自己比，因此虽然是矩阵，其实只有三角形有问题。
5. [X] : 回文相关 方法一好些，dp解法需要写一下。
==== edit distance相关 ====
583. [X] 删除相关的editdistance状态方程
==== 子序列相关 ====
53. [X] easy
==== 归纳法 ====
22. [X] ====利用dp模拟括号归纳法，达成回溯的作用。关键在于思路。
96. [X] ====不同二叉树的数量，排列组合与dp的深度结合
62. [ ] easy
63. [ ] easy
64. [ ] easy
279. [ ] 不是很容易想到，写法注意牵涉到浮点数精度的各种边界条件考虑。
120. [X] 归纳法，三角形的写法。
==== 与贪心的结合 ====
45. [X] 其实并不是标准的dp，需要明白建模的重要性。
55. [X] 边界条件注意一下


53. [ ] :
97. [X] 写一下转换方程
1027. 最长等差数列

=== dfs bfs union find ===
200 快速复习一下边界条件

== questions ==
===med===
==== ?? ====
2.  两数相加: easy
3.  重复字符的最长子串:
5.  长回文子串:
6. [X]  字形变换: Done
7. [X] 整数反转
8.  字符串转换整数 (atoi)
11. 最多水的容器
12. 数转罗马数字
15. 数之和
16. 接近的三数之和
17. 话号码的字母组合
18. 数之和
19. [X] 除链表的倒数第 N 个结点:快慢指针+新建一个的fake的头
22. 号生成
24. 两交换链表中的节点
29. 数相除
31. 一个排列
33. 索旋转排序数组
34. 排序数组中查找元素的第一个和最后一个位置
36. [X] ------------有效的数独，参考一下map的设计方法。
38. 观数列
39. 合总和
40. 合总和 II
43. 符串相乘
45. 跃游戏 II
46. 排列
47. 排列 II
48. 转图像
49. 母异位词分组
50. w(x, n)
53. 大子数组和
54. 旋矩阵
55. 跃游戏
56. 并区间
57. 入区间
59. 旋矩阵 II
61. 转链表
62. [X] easy - 不同路径
63. 不同路径 II
64. 小路径和
71. 化路径
73. 阵置零
74. 索二维矩阵
75. 色分类
77. 合
78. 集
79. 词搜索
80. 除有序数组中的重复项 II
81. 索旋转排序数组 II
82. 除排序链表中的重复元素 II
86. 隔链表
89. 雷编码
90. 集 II
91. 码方法
92. 转链表 II
93. 原 IP 地址
95. [X] 不同的二叉搜索树 II =========================树的递归回溯的写法，可以当成参考模板进行复习。
96. [X] 不同的二叉搜索树
97. [X] 验证二叉搜索树 ======================搜索树的中递归
98. [X] ============================== isBSTTree 容易写错, bst必然和遍历相关，所以状态比较可以从这个角度来说。
99. [X] 恢复二叉搜索树============================== 有两个元素错位了，写出来了，但是边界条件较为注意，一个是要注意遍历树是递归的，需要有个保险的方式终止循环。还有一个cornercase是最小值的问题（INT_MIN），注意画图确保前一个和后一个。另外就是手动画一下放错的两个元素相邻与不相邻的情况。
100. [X] 复二叉搜索树

==== 1?? ====
102. [ ] 可以熟悉一下写法而已
103.
105.
106.
107.
109.
113.
114.
116.
117.
120. [ ] ===========triangle 最小路径（注意写法）
122.
128.
129.
131.
133.
134.
137.
138.
139. [ ] dp 写一下
142.
143. [ ] 熟悉一下写法吧
146. [ ] 好好学习一下
147:148 : ******************************** 链表排序大成 *********快慢指针、merge链表、分治***链表处理头节点可以用个dummyHeader临时处理一下。****** 需要好好想一下downTOTop的设计流程
150. [ ] easy
151.
152. [ ] dp, *******************注意状态转换别漏了
153. [ ] ] : 二分查找，注意边界条件
155. [ ] 设计设计设计设计
156. [ ] 放弃
159. [ ] twopointer，hashmap存位置
161. [X] ] : 踏实的实现，cpp利用递归实现参数交换复制（switch）
162. [ ] 这个条件很tricky nums[-1] = nums[n] = -∞
165. [ ] cpp的2 pointers实现split扫描
166.
167. [ ] ] EASY
172. [ ] ======== 定义sort函数:
173. [ ] 叉搜索树迭代器
179. [ ] 大数:******熟悉一下如何定义排序*******
187. [ ] ] EASY dna, 直接写
189. [ ] ========= 数组挪动和反转的trick
198. [ ] ] EASY dp
199. [ ] ] easy

==== 2?? ====
209. [X] ] ***注意终止条件。
230. [ ] ] ***注意终止条件。
236. [ ] 叉树的最近公共祖先  注意自己是自己的祖先。
238. [ ] 单回忆一下
240. [ ] 维有序矩阵的查找…………
279. [X] dp, *******************注意状态转换别漏了
298. [X] ======注意cache
299. [X] ======简单记忆一下

==== 3?? ====
365. [X] ************* 再仔细理解一下搜索 *********************


==== 4?? ====
498. [ ] 对角线遍历还好

=== 50? ===
501. binary search tree中序遍历其实就是从小到大排序遍历
502. [ ]  ????
503. [X] 用stack构建一个< >排序的方法......
583. [X] EditDistance DP

== TODO ==
=== cpp ===
* union find
* bfs
* dfs
* [X] sort

* math
'''
#include <algorithm>
std::max
'''
==== cpp ====
* [X] 如何定制sort函数
